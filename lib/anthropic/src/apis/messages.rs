// See: https://docs.anthropic.com/claude/reference/messages_post

//! Messages API

use eventsource_client as es;
use futures::stream::{Stream, StreamExt};
use std::collections::HashMap;

use crate::requests::Requests;
use crate::{Anthropic, ApiResult, Content, Message, Usage, error};
use serde::{Deserialize, Serialize};

use super::MESSAGES_CREATE;

#[derive(Debug, Serialize, Deserialize)]
pub struct MessageBody {
    /// The model that will complete your prompt.
    /// See this link for additional details and options: https://docs.anthropic.com/claude/docs/models-overview
    pub model: String,
    /// Input messages.
    pub messages: Vec<Message>,
    /// The maximum number of tokens to generate before stopping.
    pub max_tokens: Option<i32>,
    /// An object describing metadata about the request.
    pub metadata: Option<HashMap<String, String>>,
    /// Custom text sequences that will cause the model to stop generating.
    pub stop_sequences: Option<Vec<String>>,
    /// Whether to incrementally stream the response using server-sent events.
    pub stream: Option<bool>,
    /// System prompt
    pub system: Option<String>,
    /// Amount of randomness injected into the response.
    pub temerature: Option<f32>,
    /// Only sample from the top K options for each subsequent token.
    pub top_k: Option<f32>,
    /// Use nucleus sampling.
    pub top_p: Option<f32>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MessageResponse {
    /// Unique object identifier.
    pub id: String,
    /// Object type.
    pub r#type: String,
    /// Conversational role of the generated message.
    pub role: String,
    /// Content generated by the model.
    pub content: Content,
    /// The model that handled the request.
    pub model: String,
    /// The reason that the model stopped.
    pub stop_reason: Option<String>,
    /// Which custom stop sequence was generated, if any.
    pub stop_sequence: Option<String>,
    /// Billing and rate-limit usage.
    pub usage: Usage,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Delta {
    /// Determines the content shape.
    pub r#type: String,
    /// Response content
    pub text: Option<String>,
    pub stop_reason: Option<String>,
    pub end_turn: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct MessageEvent {
    /// Event type
    pub r#type: String,
    /// Init message
    pub message: Option<MessageResponse>,
    /// Event index
    pub index: Option<i32>,
    /// Content block
    pub content_block: Option<Content>,
    /// Delta block
    pub delta: Option<Delta>,
    /// Usage
    pub usage: Option<Usage>,
}

pub trait MessageApi {
    /// Create a Message
    fn message_create(&self, message_body: &MessageBody) -> ApiResult<MessageResponse>;
    fn message_stream(
        &self,
        message_body: &MessageBody,
    ) -> Result<impl Stream<Item = Result<es::SSE, error::Error>>, error::Error>;
}

impl MessageApi for Anthropic {
    fn message_create(&self, message_body: &MessageBody) -> ApiResult<MessageResponse> {
        let request_body = serde_json::to_value(message_body).unwrap();
        let res = self.post(MESSAGES_CREATE, request_body)?;
        let response: MessageResponse = serde_json::from_value(res).unwrap();
        Ok(response)
    }

    fn message_stream(
        &self,
        message_body: &MessageBody,
    ) -> Result<impl Stream<Item = Result<es::SSE, error::Error>>, error::Error> {
        let request_body = serde_json::to_value(message_body).unwrap();
        let original_stream = self
            .stream(MESSAGES_CREATE, request_body)
            .map_err(|e| error::Error::SseStreamCreation(Box::new(e)))?;

        // Assuming you have From or Into traits implemented for conversions
        let mapped_stream = original_stream.map(|item| {
            item.map_err(error::Error::from)
            // item.map(|sse| anthropic::SSE::from(sse)).map_err(|e| error::Error::from(e))
        });

        Ok(mapped_stream)
    }
}
